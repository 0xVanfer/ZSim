
# **ZSim APL设计书**

## 0、前言

​	本文档介绍了ZSim中APL模块（APL）的脚本规则和语法，以帮助每一位想要自己定制队伍手法、寻找更优解的ZSim使用者。

> APL是什么：
>
> ​	APL（Action Priority List） 是《魔兽世界》的一款战斗模拟器（ SimulationCraft） 中一个核心功能，用于定义角色在模拟战斗中执行技能的优先级顺序。通过APL，可以对游戏角色的输出流程进行定制化管理，并且，由程序以100%的完成度进行执行。
>
> <details>
>   <summary>点击查看详细内容</summary>
>   <p style="text-indent: 2em;">通常，针对同一个角色或是队伍的手法讨论，只能基于玩家的感觉来进行，对于“怎么打比较合适”的手法细节讨论，往往得不出一个最终的结论。即使我们能够借助第三方的游戏计算器，让局部总伤计算更加精确，但也最多只能做到局部精确。某个手法或是某种输出策略对于全局战斗的影响，依旧是难以计算和模拟的。</p>
>   <p style="text-indent: 2em;">所以，模拟仿真计算器以及APL脚本应运而生。二者结合，就可以真正实现不同策略之间的公平比较，比如：某角色有能量和豆子两种资源，那么到底是优先打能量资源，还是优先打豆子资源呢？通过APL的控制，我们可以设计两套手法，一套永远先打能量，一套永远先打豆子。APL就好像一个水平超高的玩家，它会清晰、稳定地执行我们设计好的既定手法。</p>
>   <p style="text-indent: 2em;">最终，我们从模拟结果上，可以看到两套手法方案被百分百执行时的输出水平，从而找出其中最优的输出策略。这样的仿真思路，在很多游戏中都能见到，比如Simc、Gscim（原神的模拟仿真软件）等。</p>
>   <p style="text-indent: 2em;">本模拟器（ZZZSim） 的APL功能正是仿照Simc的APL运行逻辑写的。但是在具体的运行上有一些不同。语法上也针对游戏特色进行了一些优化和改动。</p>
> </details>	

---------------

## **1、ZSim中APL模块的运作原理**

​	ZSim的APL模块每次运行时，都会从APL脚本的第一行开始，逐行检验其条件部分，直到找到某一行的所有条件全部通过，就将这一行所指向的技能ID输出给下一步程序。每一行APL代码都只能指向一个动作，但是限制条件可以是多个，同一个动作的限制条件之间用“|”分隔符进行隔离，这些条件之间都是“与”关系。

​	当前版本，如果激活某动作的条件之间存在“或”关系，则应写多行APL代码。

> <details>
>   <summary>后续开发方向</summary>
>   <p style="text-indent: 2em;">目前，程序只支持“非门”和“与门”，暂不具备解析“或门”的能力。不过，该功能将会是APL功能拓展的首个目标，因为当APL脚本代码涉及到多条件中的多个“或”逻辑时，现有的脚本语法会让APL代码变得非常臃肿冗杂，所以，解析“或”逻辑的功能可以说是迫在眉睫。</p>
> </details>	

---

## 1. 基本构成

```
动作ID|条件1|条件2|条件3|条件4……
```

1. **动作ID**：APL 脚本从上到下逐行解析动作，并执行第一个满足条件的动作。
2. **条件判断**：条件是APL脚本的核心，通常是对角色和敌人的状态（如资源、冷却时间、敌人状态等）的判断。
3. **注释**：使用 `#` 开头的行作为注释，不会被解析器执行，写APL时，应对每一行的代码都进行标注，写明该动作的条件以及逻辑层次。对于比较复杂或是反常的优先级结构，则更应通过#进行说明。

---

## 2. 结构详解

​	结下来，我将对Zsim中的APL代码的每个部分进行解释。

​	首先，让我们来看看一行APL代码，这行代码的意思是：雅将在6个豆子、且身上有丽娜穿透率Buff时，使用满蓄力普攻。

```
#满豆自动放满蓄力普攻
1091|action+=|1091_SNA_3|attribute.1091:special_resource==6|buff.1091:exist→Buff-角色-丽娜-核心被动-穿透率==True
```

​	**参数解释：**

|   参数（从左到右）    | <span style="display:inline-block;width: 80px;nowrap">类型</span> | 备注                                                         |
| :-------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ |
|        `1091`         |                           角色CID                            | 在ZSim内部，雅的数字ID为1091                                 |
|      `action+=`       |                           APL类型                            | 意为“常规动作类APL”，这个暂时可以视作无用参数，但是该参数会影响APL解析，无论是缺少参数，还是内容不对，均会引起程序报错，所以还是需要按照格式填写 |
|     `1091_SNA_3`      |                            动作ID                            | 在ZSim内部，雅的蓄力普攻的ID就是“1091_SNA_3”                 |
|   `attribute.1091:`   |                           条件抬头                           | APL代码中的每一个条件模块，都由“条件抬头”和“条件主体”构成，二者之间用“：”进行分隔。条件抬头中，第一个字段的含义是：“何种类型的条件”，而第二个字段的含义是：“去哪儿查该条件”，所以，这里“attribute.1091”的含义就是：雅的属性。注意，“条件抬头”通常都具有完整的两个字段，并且用“.”进行分隔 |
| `special_resource==6` |                           条件主体                           | 这一部分就是“条件主体”了，一个标准的条件主体应该含有条件内容、比较符、结果三个部分。条件内容具体指向某个属性或是某个参数，比较符和数值则构成了“条件”本身，比如“大于XXX点”，“小于等于XXXX点”等 |
|          `|`          |                            分隔符                            | 这是分隔符，两条互为“与”关系的条件之间，应该用“\|”符号进行分隔，其含义基本等价于“且”。相应的，如果不同的条件之间的语义不能用“且”进行连接，那么就意味着它们无法在同一行APL内共存。 |

---

## 3. 关键字和条件

### 动作关键字

- **`auto_attack`**：执行基础自动攻击。当系统检测到action的内容是auto_attack时，会自动前往`character_NA_chain.json`调取对应的dict出来，并且按照读取当前的`action_stack`，找出当前动作和上一个动作，以上一个动作为键值来调出对应的值，就实现了普攻循环。
- **`skill_name`**：执行指定技能。

### 条件关键字

#### 起始字符：

#### 比较符：

-  `>` `<` `==` `<=` `>=` `!=` ：常规比较

#### 与资源相关：
- `energy>=N`：检查角色的能量值是否大于或等于 `N`。
- `esource<N`：检查角色的特殊资源是否小于 `N`。

#### 与Buff持续时间相关***（格式应该还要改）***：
- `buff_index.active=True`：检查`dynamic_buff_dict`中是否存在对应的Buff(可能涉及到循环，性能问题待优化)  
- `buff_index.dy.count<N`：检查Buff的当前层数是否小于 `N` 。

#### 与敌人状态相关：
- `enemy.health.pct<N`：检查目标的生命值百分比是否小于 `N`。
- `enemy.time_to_die>N`：检查目标预计存活时间是否大于 `N` 帧。
- `enemy.dynamic.frozen=True`：检查目标当前是否处于冻结状态。

#### 与时间相关：
- `time<N`：检查战斗持续时间是否小于 `N` 秒。
- `time>=N`：检查战斗持续时间是否大于或等于 `N` 秒。

#### 与上一个技能相关：

- **`after:last_skill_tag`**：检查上一个技能的标签。
- 

---

## 4. 书写规范

### 1. 基本格式规范
- 每行仅定义一个动作及其条件，便于阅读和解析。
- 动作和条件用 `|` 分隔，条件之间没有额外的空格。
- 条件的优先级顺序尽量从简单到复杂（例如冷却 > 资源 > 角色状态）。

### 2. 注释规范
- 使用 `#` 进行注释，说明动作的目的或触发条件。
- 注释可以位于动作行后，也可以单独占一行。

```apl
# 角色的默认攻击动作
actions+=|auto_attack
```

### 3. 条件表达式规范
- 条件复杂时，用 `|` 将逻辑拆分成多个小块，便于维护。
- 逻辑语句尽量简洁，避免冗长的嵌套。

```apl
actions+=|skill_name|if=energy>=50|cooldown.skill_name.ready
```

---

## 5. 示例

以下是完整的 APL 代码示例：

```apl
# 自动攻击，适用于所有角色
actions+=|auto_attack

# 使用饰品，当饰品冷却完成时
actions+=|use_item,name=trinket1|if=cooldown.trinket1.ready

# 主要技能，当能量 >= 50 且技能无冷却时使用
actions+=|primary_attack|if=energy>=50|cooldown.primary_attack.ready

# 增强技能，当增益 Buff 激活时触发
actions+=|empower_skill|if=buff.empowered.up

# 次要技能，用于填充能量不足时的空档期
actions+=|secondary_attack|if=energy<50
```

---

## 6. 常见错误与检查

### 错误类型
1. **条件书写错误**：
   - 漏写条件分隔符 `|` 或关键字拼写错误。
   - 示例：`ifenergy>=50` 应为 `if=energy>=50`。

2. **语法不一致**：
   - 动作和条件之间的格式不统一。

3. **优先级冲突**：
   - 高优先级动作未覆盖，导致低优先级动作无机会执行。

---

## 7. 调试与优化

1. **日志调试**：实现日志系统，记录每次执行的动作及未满足的条件。
2. **模拟战斗测试**：运行 APL 脚本模拟多种战斗场景，验证逻辑是否正确。
3. **条件优化**：调整复杂条件的顺序，提升解析效率。
